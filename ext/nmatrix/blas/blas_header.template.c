/////////////////////////////////////////////////////////////////////
// = NMatrix
//
// A linear algebra library for scientific computation in Ruby.
// NMatrix is part of SciRuby.
//
// NMatrix was originally inspired by and derived from NArray, by
// Masahiro Tanaka: http://narray.rubyforge.org
//
// == Copyright Information
//
// SciRuby is Copyright (c) 2010 - 2012, Ruby Science Foundation
// NMatrix is Copyright (c) 2012, Ruby Science Foundation
//
// Please see LICENSE.txt for additional copyright notices.
//
// == Contributing
//
// By contributing source code to SciRuby, you agree to be bound by
// our Contributor Agreement:
//
// * https://github.com/SciRuby/sciruby/wiki/Contributor-Agreement
//
// == blas.c
//
// blas.c is automatically generated by generator.rb. Do not modify
// it directly!
//
// This file contains C ports of BLAS functions that work on integer
// types and eventually rationals. You can find the original template
// in ext/nmatrix/blas/igemm.template.c.
//
// The port was accomplished using f2c (on dgemm.f) and a magnifying
// glass.
//
// Note that this is in no way comparable to ATLAS. Why?
// * We didn't test any options other than CblasNoTrans (for A and B)
// * It doesn't use any of that cool cross-over crap (e.g.,
//   Strassen's algorithm)
// * It really hasn't been tested exhaustively in any way, shape, or
//   form.
//
// This file also contains rational math helper functions so that the
// aforementioned port will work with rationals too. These are in
// ext/nmatrix/blas/rationalmath.template.c. They are derived from
// rational.c in Ruby 1.9.3.

#include "nmatrix.h"

// From cblas.h:
//enum CBLAS_ORDER {CblasRowMajor=101, CblasColMajor=102};
//enum CBLAS_TRANSPOSE {CblasNoTrans=111, CblasTrans=112, CblasConjTrans=113};
//enum CBLAS_UPLO {CblasUpper=121, CblasLower=122};
//enum CBLAS_DIAG {CblasNonUnit=131, CblasUnit=132};
//enum CBLAS_SIDE {CblasLeft=141, CblasRight=142};


// non-templated Ruby VALUE version of gemm.
int vgemm(enum CBLAS_TRANSPOSE TransA, enum CBLAS_TRANSPOSE TransB,
  const int M, const int N, const int K, const VALUE alpha,
  const VALUE* A, const int lda,
  const VALUE* B, const int ldb, const VALUE beta,
  VALUE* C, const int ldc)
{
  int num_rows_a, /*num_cols_a,*/ num_rows_b; // nrowa, ncola, nrowb
  VALUE temp; // use int64 since we're accumulating here, and it may well exceed the max int size.
  int i, j, l;

  if (TransA == CblasNoTrans) {
    num_rows_a = M;
    //num_cols_a = K;
  } else {
    num_rows_a = K;
    //num_cols_a = M;
  }

  if (TransB == CblasNoTrans) num_rows_b = K;
  else                        num_rows_b = N;

  // Test the input parameters
  if (TransA < 111 || TransA > 113) {
    fprintf(stderr, "VGEMM: TransA must be CblasNoTrans, CblasTrans, or CblasConjTrans\n");
    return 0;
  } else if (TransB < 111 || TransB > 113) {
    fprintf(stderr, "VGEMM: TransB must be CblasNoTrans, CblasTrans, or CblasConjTrans\n");
    return 0;
  } else if (M < 0) {
    fprintf(stderr, "VGEMM: Expected M >= 0\n");
    return 0;
  } else if (N < 0) {
    fprintf(stderr, "VGEMM: Expected N >= 0\n");
    return 0;
  } else if (K < 0) {
    fprintf(stderr, "VGEMM: Expected K >= 0\n");
    return 0;
  } else if (lda < NM_MAX(1, num_rows_a)) {
    fprintf(stderr, "VGEMM: Expected lda >= max(1, num_rows_a), with num_rows_a = %d; got lda=%d\n", num_rows_a, lda);
    return 0;
  } else if (ldb < NM_MAX(1, num_rows_b)) {
    fprintf(stderr, "VGEMM: Expected ldb >= max(1, num_rows_b), with num_rows_b = %d; got ldb=%d\n", num_rows_b, ldb);
    return 0;
  } else if (ldc < NM_MAX(1,M)) {
    fprintf(stderr, "VGEMM: Expected ldc >= max(1,M) with M=%d; got ldc=%d\n", M, ldc);
    return 0;
  }

  // Quick return if possible
  if (!M || !N || (!alpha || !K) && beta == 1) return 0;

  // For alpha = 0
  if (alpha == 0) {
    if (beta == 0) {
      for (j = 0; j < N; ++j)
        for (i = 0; i < M; ++i) C[i+j*ldc] = RUBY_ZERO;
    } else {
      for (j = 0; j < N; ++j)
        for (i = 0; i < M; ++i) rb_funcall(C[i+j*ldc], rb_intern("*="), 1, beta);
    }
    return 0;
  }

  // Start the operations
  if (TransB == CblasNoTrans) {
    if (TransA == CblasNoTrans) {
      // C = alpha*A*B+beta*C
      for (j = 0; j < N; ++j) {
        if (beta == 0) {
          for (i = 0; i < M; ++i) C[i+j*ldc] = RUBY_ZERO;
        } else if (beta != 1) {
          for (i = 0; i < M; ++i) C[i+j*ldc] = rb_funcall(C[i+j*ldc], nm_id_mult, 1, beta);
        }

        for (l = 0; l < K; ++l) {
          if (B[l+j*ldb] != 0) {
            temp = rb_funcall(alpha, rb_intern("*"), 1, B[l+j*ldb]);
            for (i = 0; i < M; ++i)
              rb_funcall(C[i+j*ldc], rb_intern("+="), 1, rb_funcall(A[i+l*lda], nm_id_mult, 1, temp));
          }
        }
      }

    } else {

      // C = alpha*A**T*B + beta*C
      for (j = 0; j < N; ++j) {
        for (i = 0; i < M; ++i) {
          temp = 0;
          for (l = 0; l < K; ++l)
            rb_funcall(temp, rb_intern("+="), 1, rb_funcall(A[l+i*lda], nm_id_mult, 1, B[l+j*ldb]));

          if (beta == 0)  C[i+j*ldc] = rb_funcall(alpha, nm_id_mult, 1, temp);
          else            C[i+j*ldc] = rb_funcall(rb_funcall(alpha, nm_id_mult, 1, temp), nm_id_add, 1, rb_funcall(beta, nm_id_mult, 1, C[i+j*ldc])); //alpha*temp + beta*C[i+j*ldc];
        }
      }

    }

  } else if (TransA == CblasNoTrans) {

    // C = alpha*A*B**T + beta*C
    for (j = 0; j < N; ++j) {
      if (beta == 0) {
        for (i = 0; i < M; ++i) C[i+j*ldc] = RUBY_ZERO;
      } else if (beta != 1) {
        for (i = 0; i < M; ++i) rb_funcall(C[i+j*ldc], nm_id_multeq, 1, beta);
      }

      for (l = 0; l < K; ++l) {
        if (B[j+l*ldb] != 0) {
          temp = alpha * B[j+l*ldb];
          for (i = 0; i < M; ++i)
            rb_funcall(C[i+j*ldc], rb_intern("+="), 1, rb_funcall(A[i+l*lda], nm_id_mult, 1, temp));
        }
      }

    }

  } else {

    // C = alpha*A**T*B**T + beta*C
    for (j = 0; j < N; ++j) {
      for (i = 0; i < M; ++i) {
        temp = 0;
        for (l = 0; l < K; ++l) //temp += A[l+i*lda] * B[j+l*ldb];
          rb_funcall(temp, rb_intern("+="), 1, rb_funcall(A[l+i*lda], nm_id_mult, 1, B[j+l*ldb]));

        if (beta == 0) C[i+j*ldc] = rb_funcall(alpha, nm_id_mult, 1, temp);
        else           C[i+j*ldc] = rb_funcall(rb_funcall(alpha, nm_id_mult, 1, temp), nm_id_add, 1, rb_funcall(beta, nm_id_mult, 1, C[i+j*ldc]));
      }
    }

  }

  return 0;
}





